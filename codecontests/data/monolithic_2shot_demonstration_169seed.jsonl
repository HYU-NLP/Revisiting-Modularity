{"problem_description": ["A prime number is a number which has exactly two distinct divisors: one and itself. For example, numbers 2, 7, 3 are prime, and 1, 6, 4 are not.\n\nThe next prime number after x is the smallest prime number greater than x. For example, the next prime number after 2 is 3, and the next prime number after 3 is 5. Note that there is exactly one next prime number after each number. So 5 is not the next prime number for 2.\n\nOne cold April morning Panoramix predicted that soon Kakofonix will break free from his straitjacket, and this will be a black day for the residents of the Gallic countryside.\n\nPanoramix's prophecy tells that if some day Asterix and Obelix beat exactly x Roman soldiers, where x is a prime number, and next day they beat exactly y Roman soldiers, where y is the next prime number after x, then it's time to wait for Armageddon, for nothing can shut Kakofonix up while he sings his infernal song.\n\nYesterday the Gauls beat n Roman soldiers and it turned out that the number n was prime! Today their victims were a troop of m Romans (m > n). Determine whether the Gauls should wait for the black day after today's victory of Asterix and Obelix?\n\nInput\n\nThe first and only input line contains two positive integers \u2014 n and m (2 \u2264 n < m \u2264 50). It is guaranteed that n is prime.\n\nPretests contain all the cases with restrictions 2 \u2264 n < m \u2264 4.\n\nOutput\n\nPrint YES, if m is the next prime number after n, or NO otherwise.\n\nExamples\n\nInput\n\n3 5\n\n\nOutput\n\nYES\n\nInput\n\n7 11\n\n\nOutput\n\nYES\n\nInput\n\n7 9\n\n\nOutput\n\nNO", "A bracket sequence is a string that is one of the following:\n\n1. An empty string;\n2. The concatenation of `(`, A, and `)` in this order, for some bracket sequence A ;\n3. The concatenation of A and B in this order, for some non-empty bracket sequences A and B /\n\n\n\nGiven are N strings S_i. Can a bracket sequence be formed by concatenating all the N strings in some order?\n\nConstraints\n\n* 1 \\leq N \\leq 10^6\n* The total length of the strings S_i is at most 10^6.\n* S_i is a non-empty string consisting of `(` and `)`.\n\nInput\n\nInput is given from Standard Input in the following format:\n\n\nN\nS_1\n:\nS_N\n\n\nOutput\n\nIf a bracket sequence can be formed by concatenating all the N strings in some order, print `Yes`; otherwise, print `No`.\n\nExamples\n\nInput\n\n2\n)\n(()\n\n\nOutput\n\nYes\n\n\nInput\n\n2\n)(\n()\n\n\nOutput\n\nNo\n\n\nInput\n\n4\n((()))\n((((((\n))))))\n()()()\n\n\nOutput\n\nYes\n\n\nInput\n\n3\n(((\n)\n)\n\n\nOutput\n\nNo"], "public_tests": [{"input": ["7 9\n", "3 5\n", "7 11\n"], "output": ["NO\n", "YES\n", "YES\n"]}, {"input": ["3\n(((\n)\n)", "2\n)\n(()", "4\n((()))\n((((((\n))))))\n()()()", "2\n)(\n()"], "output": ["No", "Yes", "Yes", "No"]}], "private_tests": [{"input": ["2 6\n", "31 33\n", "2 11\n", "41 49\n", "13 17\n", "23 29\n", "7 8\n", "5 13\n", "47 50\n", "43 47\n", "17 19\n", "5 9\n", "2 50\n", "2 3\n", "3 7\n", "13 20\n", "11 13\n", "19 23\n", "5 11\n", "3 9\n", "5 6\n", "23 25\n", "43 49\n", "5 7\n", "3 4\n", "7 13\n", "3 6\n", "37 41\n", "13 15\n", "2 7\n", "5 15\n", "47 48\n", "2 5\n", "31 37\n", "29 31\n", "19 21\n", "2 4\n", "41 43\n", "47 49\n"], "output": ["NO\n", "NO\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "NO\n", "YES\n", "NO\n", "NO\n", "NO\n", "NO\n", "NO\n", "YES\n", "YES\n", "NO\n", "NO\n", "YES\n", "NO\n"]}, {"input": [], "output": []}], "transformed_sc": ["n, m = map(int, input().split())\nfound = False\nnum = n + 1\nwhile True:\n    if num < 2:\n        prime = False\n    else:\n        prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                prime = False\n                break\n    if prime:\n        if num == m:\n            print(\"YES\")\n            found = True\n        break\n    num += 1\nif not found:\n    print(\"NO\")", "import sys\n\n\nn = int(input())\ns = [list(input()) for _ in range(n)]\n\nct1_total = 0\nct2_total = 0\nL = []\n\nfor i in range(n):\n    ct1 = 0\n    ct2 = 0\n\n    for char in s[i]:\n        if char == '(':\n            ct1 += 1\n        else:\n            ct2 += 1\n            \n    ct1_total += ct1\n    ct2_total += ct2\n    \n    ct1 = 0\n    ct2 = 0\n    l = [0]\n\n    for char in s[i]:\n        if char == '(':\n            ct1 += 1\n            l.append(ct1)\n        else:\n            ct2 += 1\n            l.append(-ct2)\n            \n    L.append(l)\n\nif ct1_total != ct2_total:\n    result = 'No'\n    print(result)\n    sys.exit()\n\nL1 = []\nL2 = []\n\nfor l in L:\n    if l[-1] >= 0:\n        L1.append((min(l), l[-1]))\n    else:\n        L2.append((min(l) - l[-1], -l[-1]))\n\nL1.sort()\nL1.reverse()\nct4 = 0\n\nresult1 = ''\nfor i in range(len(L1)):\n    if ct4 + L1[i][0] < 0:\n        result1 = 'No'\n    ct4 += L1[i][1]\n\nif result1 == '':\n    result1 = 'Yes'\n\nL2.sort()\nL2.reverse()\nct4 = 0\n\nresult2 = ''\nfor i in range(len(L2)):\n    if ct4 + L2[i][0] < 0:\n        result2 = 'No'\n    ct4 += L2[i][1]\n\nif result2 == '':\n    result2 = 'Yes'\n\nif result1 == 'Yes' and result2 == 'Yes':\n    result = 'Yes'\nelse:\n    result = 'No'\n\nprint(result)"], "sc": ["n,m=map(int,input().split())\ni=n+1\nfor i in range(i,m+1):\n    t=0\n    for j in range(2,i):\n        if(i%j==0):\n            t=1\n            break\n\n    if((i==m and t==1 )or t==0 and i!=m):\n        print(\"NO\")\n        break\n    elif(i==m and t==0):\n        print(\"YES\")\n        break\n    else:\n        continue\n    \n        \n        \n", "import sys\nn=int(input())\ns=[list(input()) for i in range(n)]\nL1=[]\nL2=[]\nct1=0;ct2=0\nfor i in range(n):\n  ct3=0\n  l=[0]\n  for j in range(len(s[i])):\n    if s[i][j]=='(':\n      ct1+=1\n      ct3+=1\n      l.append(ct3)\n    else:\n      ct2+=1\n      ct3-=1\n      l.append(ct3)\n  if l[-1]>=0:\n    L1.append((min(l),l[-1]))\n  else:\n    L2.append((min(l)-l[-1],-l[-1]))\nif ct1!=ct2:\n  print('No')\n  sys.exit()\n\nL1.sort()\nL1.reverse()\nct4=0\nfor i in range(len(L1)):\n  if ct4+L1[i][0]<0:\n    print('No')\n    sys.exit()\n  ct4+=L1[i][1]\n\nL2.sort()\nL2.reverse()\nct5=0\nfor i in range(len(L2)):\n  if ct5+L2[i][0]<0:\n    print('No')\n    sys.exit()\n  ct5+=L2[i][1]\n\nprint('Yes')"], "sc_cc": [10.0, 11.0], "transformed_mc": ["\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef find_next_prime(n):\n    i = n + 1\n    while True:\n        if is_prime(i):\n            return i\n        i += 1\n\ndef check_for_black_day(n, m):\n    next_prime = find_next_prime(n)\n    if next_prime == m:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef main():\n    n, m = map(int, input().split())\n    result = check_for_black_day(n, m)\n    print(result)\n\nif __name__ == '__main__':\n    main()\n", "import sys\n\ndef read_input():\n    n = int(input())\n    s = [list(input()) for _ in range(n)]\n    return n, s\n\ndef count_brackets(s):\n    ct1 = 0\n    ct2 = 0\n\n    for char in s:\n        if char == '(':\n            ct1 += 1\n        else:\n            ct2 += 1\n\n    return ct1, ct2\n\ndef process_string(s):\n    ct1 = 0\n    ct2 = 0\n    l = [0]\n\n    for char in s:\n        if char == '(':\n            ct1 += 1\n            l.append(ct1)\n        else:\n            ct2 += 1\n            l.append(-ct2)\n\n    return l\n\ndef check_valid_sequences(L):\n    L1 = []\n    L2 = []\n\n    for l in L:\n        if l[-1] >= 0:\n            L1.append((min(l), l[-1]))\n        else:\n            L2.append((min(l) - l[-1], -l[-1]))\n\n    return L1, L2\n\ndef check_sequence_order(L, ct):\n    L.sort()\n    L.reverse()\n    ct4 = 0\n\n    for i in range(len(L)):\n        if ct4 + L[i][0] < 0:\n            return 'No'\n        ct4 += L[i][1]\n\n    return 'Yes'\n\ndef check_bracket_sequence(n, s):\n    ct1_total = 0\n    ct2_total = 0\n    L = []\n\n    for i in range(n):\n        ct1, ct2 = count_brackets(s[i])\n        ct1_total += ct1\n        ct2_total += ct2\n        l = process_string(s[i])\n        L.append(l)\n\n    if ct1_total != ct2_total:\n        return 'No'\n\n    L1, L2 = check_valid_sequences(L)\n\n    result1 = check_sequence_order(L1, ct1_total)\n    result2 = check_sequence_order(L2, ct2_total)\n\n    if result1 == 'Yes' and result2 == 'Yes':\n        return 'Yes'\n    else:\n        return 'No'\n\ndef main():\n    n, s = read_input()\n    result = check_bracket_sequence(n, s)\n    print(result)\n\nif __name__ == '__main__':\n    main()"]}
