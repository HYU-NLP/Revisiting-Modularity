{"problem_id":944,"problem_description":"Given an array $A$ of length $N$.\nWe have to find the $maximum$ sum of elements of the subarray between $two$ nearest occurrences of $same$ elements (excluding both).\nIf both the elements are $even$ then the total number of $even$ elements in that subarray should be $even$ then and then only we consider that subarray and if both the elements are $odd$ then the total number of $odd$ element in that subarray should be $odd$ then and then only we consider that subarray.\nIf the condition never matches print $0$.\n\n-----Input:-----\n- First line contains $T$, number of test cases. Then the test cases follow.\n- Each testcase consists of two lines: \nThe first line has $N$ : number of elements in the array and second-line has $N$ space separated integers: elements of the array.\n\n-----Output:-----\n- For each test case, output in a single line $maximum$ sum.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10$\n- $3 \\leq N \\leq 2*10^5$\n- $1 \\leq A[i] \\leq 10^8$\n$NOTE $: Use of Fast Input Output is recommended.\n\n-----Sample Input:-----\n1\n10\n1 2 3 2 1 5 1 2 8 2\n\n-----Sample Output:-----\n7\n\n-----EXPLANATION:-----\nThe maximum sum is 7, between 1 at  1st position and 1 at 5th position i.e sum of 2,3,2","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"from sys import stdin, stdout\nfrom collections import defaultdict\nfor _ in range(int(stdin.readline())):\n    n=int(stdin.readline())\n    lst=list(map(int, stdin.readline().split()))\n    prefix_odd=[0]*n\n    prefix_even=[0]*n\n    odd_val=0\n    even_val=0\n    for i in range(n):\n        if lst[i]%2==0:\n            even_val+=1 \n        else:\n            odd_val+=1\n        prefix_even[i]=even_val\n        prefix_odd[i]=odd_val\n    \n    prefix_sum=[0]*n\n    s=0\n    for i in range(n):\n        s+=lst[i]\n        prefix_sum[i]=s\n    \n    dict={}\n    count={}\n    for i in range(n):\n        if lst[i] not in dict:\n            dict[lst[i]]=i\n            count[lst[i]]=1\n        else:\n            dict[lst[i]]=i\n            count[lst[i]]+=1\n    \n    graph=defaultdict(list)\n    for i in range(n):\n        graph[lst[i]].append(i)\n    max_sum=0\n    for i in graph:\n        if len(graph[i])>1:\n            prev=graph[i][0]\n            for j in range(1,len(graph[i])):\n                index2=graph[i][j]\n                index1=prev\n                prev=index2\n                \n                if i%2==0:\n                    val=prefix_even[index2]-prefix_even[index1]-1\n                    \n                    if val%2==0:\n                        temp_sum=prefix_sum[index2]-prefix_sum[index1]-i\n                        \n                        if temp_sum>max_sum:\n                            max_sum=temp_sum\n                else:\n                    val=prefix_odd[index2]-prefix_odd[index1]-1\n                    \n                    if val%2!=0:\n                        temp_sum=prefix_sum[index2]-prefix_sum[index1]-i\n                        \n                        if temp_sum>max_sum:\n                            max_sum=temp_sum\n\n    \n    \n    stdout.write(str(max_sum)+'\\n')","sc_cc":16.0,"mc":"from sys import stdin,stdout\r\nfrom itertools import accumulate\r\ndef Oddnos(l,r):\r\n    smm=od[r-1]-od[l]\r\n    return smm&1\r\ndef evennos(l,r):\r\n    tot=(r-l-1)\r\n    smm=od[r-1]-od[l]\r\n    return ((tot-smm)&1==0)\r\ndef getSum(l,r):\r\n    return ps[r]-(ps[l-1] if l>=1 else 0)\r\nfor _ in range(int(stdin.readline())):\r\n    n=int(stdin.readline())\r\n    a=list(map(int,stdin.readline().split()))\r\n    od=list(accumulate([x&1 for x in a]))\r\n    ps=list(accumulate(a))\r\n    d={};mx=0\r\n    for i in range(n):\r\n        if a[i] in d:\r\n            prev=d[a[i]]\r\n            if a[i]&1 and Oddnos(prev,i):\r\n                mx=max(mx,getSum(prev,i)-2*a[i])\r\n            elif a[i]&1==0 and evennos(prev,i):\r\n                mx = max(mx, getSum(prev,i) - 2 * a[i])\r\n        d[a[i]]=i\r\n    print(mx)","mc_cc":3.25,"transformed_mc":["\nfrom sys import stdin, stdout\nfrom collections import defaultdict\n\ndef calculate_prefix_sums(lst):\n    n = len(lst)\n    prefix_odd = [0] * n\n    prefix_even = [0] * n\n    odd_val = 0\n    even_val = 0\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            even_val += 1\n        else:\n            odd_val += 1\n        prefix_even[i] = even_val\n        prefix_odd[i] = odd_val\n    return prefix_odd, prefix_even\n\ndef calculate_prefix_sum(lst):\n    prefix_sum = [0] * len(lst)\n    s = 0\n    for i in range(len(lst)):\n        s += lst[i]\n        prefix_sum[i] = s\n    return prefix_sum\n\ndef build_element_index_map(lst):\n    element_index_map = {}\n    count = {}\n    for i in range(len(lst)):\n        if lst[i] not in element_index_map:\n            element_index_map[lst[i]] = i\n            count[lst[i]] = 1\n        else:\n            element_index_map[lst[i]] = i\n            count[lst[i]] += 1\n    return element_index_map, count\n\ndef find_maximum_subarray_sum(lst, prefix_odd, prefix_even, prefix_sum, element_index_map):\n    max_sum = 0\n    graph = defaultdict(list)\n    for i in range(len(lst)):\n        graph[lst[i]].append(i)\n    for key in graph:\n        if len(graph[key]) > 1:\n            prev = graph[key][0]\n            for j in range(1, len(graph[key])):\n                index2 = graph[key][j]\n                index1 = prev\n                prev = index2\n                if key % 2 == 0:\n                    val = prefix_even[index2] - prefix_even[index1] - 1\n                    if val % 2 == 0:\n                        temp_sum = prefix_sum[index2] - prefix_sum[index1] - key\n                        if temp_sum > max_sum:\n                            max_sum = temp_sum\n                else:\n                    val = prefix_odd[index2] - prefix_odd[index1] - 1\n                    if val % 2 != 0:\n                        temp_sum = prefix_sum[index2] - prefix_sum[index1] - key\n                        if temp_sum > max_sum:\n                            max_sum = temp_sum\n    return max_sum\n\ndef main():\n    for _ in range(int(stdin.readline())):\n        n = int(stdin.readline())\n        lst = list(map(int, stdin.readline().split()))\n        prefix_odd, prefix_even = calculate_prefix_sums(lst)\n        prefix_sum = calculate_prefix_sum(lst)\n        element_index_map, _ = build_element_index_map(lst)\n        max_sum = find_maximum_subarray_sum(lst, prefix_odd, prefix_even, prefix_sum, element_index_map)\n        stdout.write(str(max_sum) + '\\n')\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["from sys import stdin, stdout\nfrom collections import defaultdict\n\nfor _ in range(int(stdin.readline())):\n    n = int(stdin.readline())\n    lst = list(map(int, stdin.readline().split()))\n\n    n = len(lst)\n    prefix_odd = [0] * n\n    prefix_even = [0] * n\n    odd_val = 0\n    even_val = 0\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            even_val += 1\n        else:\n            odd_val += 1\n        prefix_even[i] = even_val\n        prefix_odd[i] = odd_val\n\n    prefix_sum = [0] * len(lst)\n    s = 0\n    for i in range(len(lst)):\n        s += lst[i]\n        prefix_sum[i] = s\n\n    element_index_map = {}\n    count = {}\n    for i in range(len(lst)):\n        if lst[i] not in element_index_map:\n            element_index_map[lst[i]] = i\n            count[lst[i]] = 1\n        else:\n            element_index_map[lst[i]] = i\n            count[lst[i]] += 1\n\n    max_sum = 0\n    graph = defaultdict(list)\n    for i in range(len(lst)):\n        graph[lst[i]].append(i)\n    for key in graph:\n        if len(graph[key]) > 1:\n            prev = graph[key][0]\n            for j in range(1, len(graph[key])):\n                index2 = graph[key][j]\n                index1 = prev\n                prev = index2\n                if key % 2 == 0:\n                    val = prefix_even[index2] - prefix_even[index1] - 1\n                    if val % 2 == 0:\n                        temp_sum = prefix_sum[index2] - prefix_sum[index1] - key\n                        if temp_sum > max_sum:\n                            max_sum = temp_sum\n                else:\n                    val = prefix_odd[index2] - prefix_odd[index1] - 1\n                    if val % 2 != 0:\n                        temp_sum = prefix_sum[index2] - prefix_sum[index1] - key\n                        if temp_sum > max_sum:\n                            max_sum = temp_sum\n    stdout.write(str(max_sum) + \"\n\")\n"]}
{"problem_id":1499,"problem_description":"Given $N *M$ matrix containing elements either $1$ or $0$ and string S of length $N+M-1$ containing characters $0$ or $1$. Your task is to make all the  paths from top left corner to the  bottom right corner of the matrix same as the  given string .You can perform two types of operations any time .Path means you can only allow it to take right or down. \nOperations :\n- Changing the matrix elements from $1$ to $0$ or vice versa  will cost P rupees per element.\n- Changing the character of string  from $1$ to $0$ or vice versa  will cost Q rupees per character.\nYou have to  minimize the cost, (possibly 0) .\n\n-----Input:-----\n- First line of input contains the total no. of test cases $T$. \n- For every test case, first line of input contains two spaced positive integers, $N$ and $M$.\n- Next $N$ lines contains $M$-spaced integers which can be only $0$ or $1$.\n- Next line of input contains a string $S$ of length $N+M-1$.\n- Last line of input contains two spaced integers, $P$ and $Q$.\n\n-----Output:-----\n- $You$ $have$ $to$ $print$ $the$ $minimum$ $cost .$\n\n-----Constraints-----\n- $1 \\leq T \\leq 20$\n- $1 \\leq N, M \\leq 1000$\n- $|S| = N+M-1$\n- $0 \\leq P, Q \\leq 1000$The input\/output is quite large, please use fast reading and writing methods.\n\n-----Sample Input-----\n2\n3 3\n1 0 1\n0 1 1\n1 1 0\n10111\n10 5\n3 3 \n0 0 1\n0 1 1\n0 1 1\n00011\n2 9\n\n-----Sample Output-----\n5\n4\n\n-----Explanation-----\n- You can  change the last element of the matrix and also can change the last element of string but the minimum cost will produce by changing string element , therefore it will cost 5 rupees.","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"import sys;input = sys.stdin.readline\n\ninp,ip = lambda :int(input()),lambda :[int(w) for w in input().split()]\n\nfor _ in range(inp()):\n n,m = ip()\n x = [ip() for i in range(n)]\n s = input().strip()\n p,q = ip()\n ans = 0\n for i in range(n+m-1):\n  dt = {0:0,1:0}\n  if i < m:\n   row,col = 0,i\n  else:\n   row,col = i-m+1,m-1\n  while col >= 0 and row < n:\n   dt[x[row][col]] += 1\n   col -= 1\n   row += 1\n  if s[i] == '0':\n   t = min(dt[1]*p,q+dt[0]*p)\n  elif s[i] == '1':\n   t = min(dt[0]*p,q+dt[1]*p)\n  ans += t\n print(ans)","sc_cc":10.0,"mc":"import sys\ndef get_ints(): return map(int, sys.stdin.readline().strip().split())\ndef get_list(): return list(map(int, sys.stdin.readline().strip().split()))\ndef get_string(): return sys.stdin.readline().strip()\n\ndef row_helper(data,s,p,q):\n t1 = 0\n for i in range(len(data[0])):\n  if(data[0][i] != int(s[i])):\n   t1 += min(p,q)\n return t1\n\ndef col_helper(data,s,p,q):\n t1 = 0\n for i in range(len(data)):\n  if(data[i][0] != int(s[i])):\n   t1 += min(p,q)\n return t1\n\nfor _ in range(int(input())):\n row,col = get_ints()\n data = []\n for i in range(row):\n  data.append(get_list())\n s = get_string()\n p,q = get_ints()\n if(row == 1):\n  print(row_helper(data,s,p,q))\n else:\n  if(col == 1):\n   print(col_helper(data,s,p,q))\n  else:\n   ans = 0\n   i = 0\n   while(i < row):\n    temp = []\n    x,y = i,0\n    while(x >= 0 and y < col):\n     temp.append(data[x][y])\n     x -= 1\n     y += 1\n    t1 = 0\n    for l in temp:\n     if(l != int(s[i])):\n      t1 += p\n    t2 = q\n    for l in temp:\n     if(l == int(s[i])):\n      t2 += p\n    ans += min(t1,t2)\n    i += 1\n   loop = i\n   i -= 1\n   j = 1\n   while(j < col):\n    temp = []\n    x,y = i,j\n    while(y < col and x >= 0):\n     temp.append(data[x][y])\n     y += 1\n     x -= 1\n    t1 = 0\n    for l in temp:\n     if(l != int(s[loop])):\n      t1 += p\n    t2 = q\n    for l in temp:\n     if(l == int(s[loop])):\n      t2 += p\n    ans += min(t1,t2)\n    j += 1\n    loop += 1\n   print(ans)","mc_cc":4.6666666667,"transformed_mc":["\nimport sys\ninput = sys.stdin.readline\n\ndef get_input():\n    return int(input())\n\ndef get_int_list():\n    return [int(w) for w in input().split()]\n\ndef get_matrix(n, m):\n    return [get_int_list() for _ in range(n)]\n\ndef get_string():\n    return input().strip()\n\ndef calculate_cost(n, m, matrix, s, p, q):\n    ans = 0\n    for i in range(n + m - 1):\n        dt = {0: 0, 1: 0}\n        if i < m:\n            row, col = 0, i\n        else:\n            row, col = i - m + 1, m - 1\n        while col >= 0 and row < n:\n            dt[matrix[row][col]] += 1\n            col -= 1\n            row += 1\n        if s[i] == '0':\n            t = min(dt[1] * p, q + dt[0] * p)\n        elif s[i] == '1':\n            t = min(dt[0] * p, q + dt[1] * p)\n        ans += t\n    return ans\n\ndef main():\n    inp = get_input()\n    for _ in range(inp):\n        n, m = get_int_list()\n        matrix = get_matrix(n, m)\n        s = get_string()\n        p, q = get_int_list()\n        cost = calculate_cost(n, m, matrix, s, p, q)\n        print(cost)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["import sys\ninput = sys.stdin.readline\n\ninp = int(input())\nfor _ in range(inp):\n    n, m = [int(w) for w in input().split()]\n    matrix = []\n    for __ in range(n):\n        matrix.append([int(w) for w in input().split()])\n    s = input().strip()\n    p, q = [int(w) for w in input().split()]\n    ans = 0\n    for i in range(n + m - 1):\n        dt = {0: 0, 1: 0}\n        if i < m:\n            row, col = 0, i\n        else:\n            row, col = i - m + 1, m - 1\n        while col >= 0 and row < n:\n            dt[matrix[row][col]] += 1\n            col -= 1\n            row += 1\n        if s[i] == '0':\n            t = min(dt[1] * p, q + dt[0] * p)\n        elif s[i] == '1':\n            t = min(dt[0] * p, q + dt[1] * p)\n        ans += t\n    print(ans)"]}
