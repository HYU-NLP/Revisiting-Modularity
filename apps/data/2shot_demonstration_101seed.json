{"problem_id":979,"problem_description":"You are given a grid of size M x N, where each square is colored with some random color among K colors with each having equal probability.\n\nA Good Rectangle is defined as one where all squares lying on the inner border are of the same color.\n\nWhat is the expected number of Good Rectangles in the given grid.\n\n-----Input-----\n\n- \nFirst Line contains M, N, K\n\n-----Output-----\nA single value rounded off to the nearest Integer corresponding to the required answer.\n\n-----Constraints-----\n-  1 <= N <= 105 \n-  1 <= M <= 105 \n-  1 <= K <= 105 \n\n-----Example-----\nInput:\n1 3 1\nOutput:\n6","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"n, m, k = list(map(int, input().split()))\n\nif k == 1:\n x, y = 0, 0\n for p in range(2, n + 1):\n  x += (n - p + 1)\n for p in range(2, m + 1):\n  y += (m - p + 1)\n ans = x * y\n x = 0\n for p in range(1, n + 1):\n  x += (n - p + 1)\n y = 0\n for p in range(1, m + 1):\n  y += (m - p + 1)\n ans += m * x\n ans += n * y\n ans -= n * m\n print(ans)\nelse:\n x, y = 0.0, 0.0\n q = 1.0\n for p in range(2, n + 1):\n  q \/= k * k\n  x += (n - p + 1) * q\n for p in range(2, m + 1):\n  q \/= k * k\n  y += (m - p + 1) * q\n ans = k * x * y\n x = 0.0\n q = 1.0\n for p in range(1, n + 1):\n  x += (n - p + 1) * q\n  q \/= k\n y = 0.0\n q = 1.0\n for p in range(1, m + 1):\n  y += (m - p + 1) * q\n  q \/= k\n ans += m * x\n ans += n * y\n ans -= n * m\n ans += 1e-9\n \n print(\"%.0f\" % ans)","sc_cc":10.0,"mc":"def for1(M,k):\n ret = 0.0\n x = k*k+0.0\n z=x\n for m in range(1,M):\n  ret+=(M-m)\/x\n  x*=z\n return ret \n  \ndef for2(M,k):\n ret = 0.0\n x = k+0.0\n for m in range(1,M):\n  ret+=(M-m)\/x\n  \n  x*=k\n return ret \n  \ndef ans(M,N,K):\n\n return int(round(M*N+M*for2(N,K)+N*for2(M,K)+K*for1(M,K)*for1(N,K),0))\nM,N,K = list(map(int,input().split()))\nprint(ans(M,N,K))","mc_cc":1.5,"transformed_mc":["\ndef calculate_good_rectangles(n, m, k):\n    if k == 1:\n        return calculate_good_rectangles_k1(n, m)\n    else:\n        return calculate_good_rectangles_k(n, m, k)\n\ndef calculate_good_rectangles_k1(n, m):\n    x, y = 0, 0\n    for p in range(2, n + 1):\n        x += (n - p + 1)\n    for p in range(2, m + 1):\n        y += (m - p + 1)\n    ans = x * y\n    x = 0\n    for p in range(1, n + 1):\n        x += (n - p + 1)\n    y = 0\n    for p in range(1, m + 1):\n        y += (m - p + 1)\n    ans += m * x\n    ans += n * y\n    ans -= n * m\n    return ans\n\ndef calculate_good_rectangles_k(n, m, k):\n    x, y = 0.0, 0.0\n    q = 1.0\n    for p in range(2, n + 1):\n        q \/= k * k\n        x += (n - p + 1) * q\n    for p in range(2, m + 1):\n        q \/= k * k\n        y += (m - p + 1) * q\n    ans = k * x * y\n    x = 0.0\n    q = 1.0\n    for p in range(1, n + 1):\n        x += (n - p + 1) * q\n        q \/= k\n    y = 0.0\n    q = 1.0\n    for p in range(1, m + 1):\n        y += (m - p + 1) * q\n        q \/= k\n    ans += m * x\n    ans += n * y\n    ans -= n * m\n    ans += 1e-9\n    return ans\n\ndef main():\n    n, m, k = list(map(int, input().split()))\n    ans = calculate_good_rectangles(n, m, k)\n    print(\"%.0f\" % ans)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["n, m, k = list(map(int, input().split()))\nif k == 1:\n    x, y = 0, 0\n    for p in range(2, n + 1):\n        x += (n - p + 1)\n    for p in range(2, m + 1):\n        y += (m - p + 1)\n    ans = x * y\n    x = 0\n    for p in range(1, n + 1):\n        x += (n - p + 1)\n    y = 0\n    for p in range(1, m + 1):\n        y += (m - p + 1)\n    ans += m * x\n    ans += n * y\n    ans -= n * m\nelse:\n    x, y = 0.0, 0.0\n    q = 1.0\n    for p in range(2, n + 1):\n        q \/= k * k\n        x += (n - p + 1) * q\n    for p in range(2, m + 1):\n        q \/= k * k\n        y += (m - p + 1) * q\n    ans = k * x * y\n    x = 0.0\n    q = 1.0\n    for p in range(1, n + 1):\n        x += (n - p + 1) * q\n        q \/= k\n    y = 0.0\n    q = 1.0\n    for p in range(1, m + 1):\n        y += (m - p + 1) * q\n        q \/= k\n    ans += m * x\n    ans += n * y\n    ans -= n * m\n    ans += 1e-9\nprint(\"%.0f\" % ans)"]}
{"problem_id":2109,"problem_description":"10^{10^{10}} participants, including Takahashi, competed in two programming contests.\nIn each contest, all participants had distinct ranks from first through 10^{10^{10}}-th.\nThe score of a participant is the product of his\/her ranks in the two contests.\nProcess the following Q queries:\n - In the i-th query, you are given two positive integers A_i and B_i. Assuming that Takahashi was ranked A_i-th in the first contest and B_i-th in the second contest, find the maximum possible number of participants whose scores are smaller than Takahashi's.\n\n-----Constraints-----\n - 1 \\leq Q \\leq 100\n - 1\\leq A_i,B_i\\leq 10^9(1\\leq i\\leq Q)\n - All values in input are integers.\n\n-----Input-----\nInput is given from Standard Input in the following format:\nQ\nA_1 B_1\n:\nA_Q B_Q\n\n-----Output-----\nFor each query, print the maximum possible number of participants whose scores are smaller than Takahashi's.\n\n-----Sample Input-----\n8\n1 4\n10 5\n3 3\n4 11\n8 9\n22 40\n8 36\n314159265 358979323\n\n-----Sample Output-----\n1\n12\n4\n11\n14\n57\n31\n671644785\n\nLet us denote a participant who was ranked x-th in the first contest and y-th in the second contest as (x,y).\nIn the first query, (2,1) is a possible candidate of a participant whose score is smaller than Takahashi's. There are never two or more participants whose scores are smaller than Takahashi's, so we should print 1.","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"import math\nq=int(input())\nfor j in range(q):\n\tAB=[int(i) for i in input().split()]\n\tAB.sort()\n\tab=AB[0]*AB[1] \n\tfor i in range(int(math.sqrt(ab)),AB[1]+1):\n\t\tif i*i>=ab:\n\t\t\tx=i-1\n\t\t\tbreak\n\tif x==0:\n\t\tprint(0)\n\t\tcontinue\n\tfor i in range(int(ab\/x),ab+1):\n\t\tif x*i>=ab:\n\t\t\ty=i-1\n\t\t\tbreak\n\tcnt1=2*x\n\tcnts=1 if x==y else 0\n\tcntdd=1 if x-AB[0]>=0 else 0\n\tcntdu=1 if AB[1]-y>=0 and (AB[1]+1)*(x-AB[1]+y)>=ab else 0 \n\tprint(cnt1-cnts-cntdd-cntdu)","sc_cc":12.0,"mc":"import sys\n\ninput = sys.stdin.readline\nQ = int(input())\n\ndef max_score(x, a):\n    ret = 0\n    for p in [(x-4), (x-2), x, (x+2), x+4]:\n        p += x%2\n        p \/\/= 2\n        ret = max(ret, (p+(p>=a))*(x-p+1))\n    return ret\n\nfor _ in range(Q):\n    a, b = list(map(int, input().split()))\n    a, b = min(a, b), max(a, b)\n\n    def is_ok(x):\n        return a*b > max_score(x, a)\n\n    def bisect(ng, ok):\n        while (abs(ok - ng) > 1):\n            mid = (ok + ng) \/\/ 2\n            if is_ok(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n    ans = bisect(2*b+1, a-1)\n    print(ans)","mc_cc":2.0,"transformed_mc":["\nimport math\n\ndef calculate_max_participants(AB):\n    AB.sort()\n    ab = AB[0] * AB[1]\n    \n    x = calculate_x(ab, AB)\n    if x == 0:\n        return 0\n    \n    y = calculate_y(ab, x)\n    \n    cnt1 = 2 * x\n    cnts = 1 if x == y else 0\n    cntdd = 1 if x - AB[0] >= 0 else 0\n    cntdu = 1 if AB[1] - y >= 0 and (AB[1] + 1) * (x - AB[1] + y) >= ab else 0\n    \n    return cnt1 - cnts - cntdd - cntdu\n\ndef calculate_x(ab, AB):\n    for i in range(int(math.sqrt(ab)), AB[1] + 1):\n        if i * i >= ab:\n            return i - 1\n    return 0\n\ndef calculate_y(ab, x):\n    for i in range(int(ab \/ x), ab + 1):\n        if x * i >= ab:\n            return i - 1\n\ndef main():\n    q = int(input())\n    for _ in range(q):\n        AB = [int(i) for i in input().split()]\n        result = calculate_max_participants(AB)\n        print(result)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["import math\n\nq = int(input())\nfor _ in range(q):\n    AB = [int(i) for i in input().split()]\n    AB.sort()\n    ab = AB[0] * AB[1]\n\n    x = 0\n    for i in range(int(math.sqrt(ab)), AB[1] + 1):\n        if i * i >= ab:\n            x = i - 1\n            break\n    if x == 0:\n        result = 0\n        continue\n\n    for i in range(int(ab \/ x), ab + 1):\n        if x * i >= ab:\n            y = i - 1\n            break\n    \n    cnt1 = 2 * x\n    cnts = 1 if x == y else 0\n    cntdd = 1 if x - AB[0] >= 0 else 0\n    cntdu = 1 if AB[1] - y >= 0 and (AB[1] + 1) * (x - AB[1] + y) >= ab else 0\n    result = cnt1 - cnts - cntdd - cntdu\n    print(result)"]}
