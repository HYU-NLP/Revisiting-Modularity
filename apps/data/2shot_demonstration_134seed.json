{"problem_id":1160,"problem_description":"Chef is an advocate for Go Green Initiative. Today he had n trees planted in a row outside his his restaurant. Today, the height of i-th tree is hi feet. The trees grow at a rate of mi feet per day.\nChef knows that trees will look beautiful if they form a zig-zag sequence. The trees will be said to be in Zig-zag sequence if the heights of tree first increases or decreases, then alternates between decreasing\/increasing respectively. Formally, the trees will be said to in Zig-zag sequence if one of the following two conditions holds.\n\n- h1 < h2 > h3 < h4 and so on..\n- h1 >  h2 < h3 > h4 and so on..\n\nChef wants to know intervals of time when the heights of the trees will form a zig-zag sequence.\n\n-----Input-----\nThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\nThe first line of each test case contains a single integer n, denoting the number of trees.\nThe ith of following N lines contains two space separated integers hi and mi, denoting the initial height and the growth speed for ith tree.\n\n-----Output-----\nFor each test case, output an integer Q - the amount of the periods of consecutive moments of time, when the trees for a zig-zag sequence.\nOn the following Q lines, output the intervals of time when the trees' heights form a zig-zag sequence. For each intervals, output its' smallest and the largest instants of time. If the range is infinite, output Inf as the right bound.\nThe test cases are designed in such a way that the total output won't exceed 2 MB.\n\n-----Constraints-----\n\n- 1 \u2264 T \u2264 105\n- 1 \u2264 n \u2264 10\n- Subtask 1 (23 points): 0 \u2264 hi, mi \u2264 10\n- Subtask 2 (77 points): 0 \u2264 hi, mi \u2264 109\n- 1 \u2264 sum of n over a test cases in a single test file \u2264 5 \u00d7 105\n\n-----Example-----\nInput:3\n3\n0 1\n2 2\n0 3\n2\n2 1\n1 2\n3\n1 1\n2 2\n3 3\n\nOutput:1\n0 1\n2\n0 0\n2 Inf\n0\n\n-----Explanation-----\nExample case 1. In the first case 0 2 0 is already a zig-zag sequence, but on the 2nd second it will become 2 6 6 and will never turn back into zig-zag","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"import math\ndef CHAHG1(xh,m):\n x = [x for x in xh]\n y = [y for y in m]\n \n up = []\n lw = []\n L = None\n R = None\n for i in range(0,len(x)-1):\n  if(i%2==0):\n   if((y[i]-y[i+1])==0):\n    if(x[i] < x[i+1]):\n     lw.append(0)\n    else:\n     return False\n   else:\n    if(y[i] < y[i+1]):\n     l = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     l = int(math.floor(l))+1\n     lw.append(max(0,l))\n    else:\n     r = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     r = int(math.ceil(r))-1\n     if(r<0):\n      return False\n     up.append(r)\n  else:\n   if((y[i]-y[i+1])==0):\n    if(x[i] > x[i+1]):\n     lw.append(0)\n    else:\n     return False\n   else:\n    if(y[i] > y[i+1]):\n     l = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     l = int(math.floor(l))+1\n     lw.append(max(0,l))\n    else:\n     r = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     r = int(math.ceil(r))-1\n     if(r<0):\n      return False\n     up.append(r)\n if(len(lw)>0):\n  L = max(lw)\n else:\n  L = 0\n if(len(up) > 0):\n  R = min(up)\n  if(L>R):\n   return False\n else:\n  R = \"Inf\"\n \n return L,R\n \ndef CHAHG2(xh,m):\n x = [x for x in xh]\n y = [y for y in m]\n up = []\n lw = []\n L = None\n R = None\n for i in range(0,len(x)-1):\n  if(i%2==1):\n   if((y[i]-y[i+1])==0):\n    if(x[i] < x[i+1]):\n     lw.append(0)\n    else:\n     return False\n   else:\n    if(y[i] < y[i+1]):\n     l = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     l = int(math.floor(l))+1\n     lw.append(max(0,l))\n    else:\n     r = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     r = int(math.ceil(r))-1\n     if(r<0):\n      return False\n     up.append(r)\n  else:\n   if((y[i]-y[i+1])==0):\n    if(x[i] > x[i+1]):\n     lw.append(0)\n    else:\n     return False\n   else:\n    if(y[i] > y[i+1]):\n     l = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     l = int(math.floor(l))+1\n     lw.append(max(0,l))\n    else:\n     r = (float)(x[i+1]-x[i])\/(y[i]-y[i+1])\n     r = int(math.ceil(r))-1\n     if(r<0):\n      return False\n     up.append(r)\n if(len(lw)>0):\n  L = max(lw)\n else:\n  L = 0\n if(len(up) > 0):\n  R = min(up)\n  if(L>R):\n   return False\n else:\n  R = \"Inf\"\n \n return L,R\n \nT = int(input())\nwhile T:\n T = T-1\n N = int(input())\n xh = []\n m = []\n for i in range(N):\n  a,b = list(map(int,input().split()))\n  xh.append(a)\n  m.append(b)\n \n res = []\n p = CHAHG1(xh,m)\n q = CHAHG2(xh,m)\n if(p is not False):\n  res.append(p)\n if(q is not False):\n  res.append(q)\n  \n res.sort()\n sz = len(res)\n \n if(N==1):\n  print(\"1\")\n  print(\"0 Inf\")\n else:\n  if(sz==2 and (res[0][1]+1 == res[1][0])):\n   print(\"1\")\n   print(res[0][0],res[1][1])\n  else:\n   print(sz)\n   for L,R in res:\n    print(L,R)","sc_cc":13.6666666667,"mc":"def get(l,n):\n l1,l2 = [],[]\n i = 1\n h1,m1 = l[0]\n while (i < len(l)):\n  h2,m2 = l[i]\n  if (h1>h2):\n   if (m1 >= m2):\n    l1 += [(0,10**20)]\n    l2 += [(-1,-1)]\n   else:\n    d = (h1-h2)\/\/(m2-m1)\n    if (((h1-h2)%(m2-m1)) == 0):\n     l1 += [(0,d-1)]\n     l2 += [(d+1,10**20)]\n    else:\n     l1 += [(0,d)]\n     l2 += [(d+1,10**20)]\n  elif(h1==h2):\n   if (m1 > m2):\n    l1 += [(1,10**20)]\n    l2 += [(-1,-1)]\n   elif(m1==m2):\n    l1 += [(-1,-1)]\n    l2 += [(-1,-1)]\n   else:\n    l2 += [(1,10**20)]\n    l1 += [(-1,-1)]\n  else:\n   if (m1 <= m2):\n    l2 += [(0,10**20)]\n    l1 += [(-1,-1)]\n   else:\n    d = (h2-h1)\/\/(m1-m2)\n    if ((h2-h1)%(m1-m2) == 0):\n     l2 += [(0,d-1)]\n     l1 += [(d+1,10**20)]\n    else:\n     l2 += [(0,d)]\n     l1 += [(d+1,10**20)]\n  i += 1\n  h1,m1 = h2,m2\n return l1,l2\n \ndef intersect(k1,k2):\n k1,k2 = min(k1,k2),max(k1,k2)\n c1,c2 = k1\n c3,c4 = k2\n l = [c1,c2,c3,c4]\n l.sort()\n if (l[2]==c2):\n  return (c3,min(c2,c4))\n elif (l[3]==c2):\n  return k2\n else:\n  return (-1,-1)\n \n \n \ndef union(k1,k2):\n k1,k2 = min(k1,k2),max(k1,k2)\n c1,c2 = k1\n c3,c4 = k2\n l = [c1,c2,c3,c4]\n l.sort()\n if (c2==l[3]):\n  return ([c1,c2])\n elif(c2==l[2] or ((c3-c2) == 1)):\n  return([c1,c4])\n else:\n  return([c1,c2,c3,c4])\n \n \ndef aa(l1,l2,n):\n c1,c2 = 0,10**20\n i = 0\n n -= 1\n while (i < n):\n  if (i%2 == 0):\n   k1,k2 = l1[i]\n  else:\n   k1,k2 = l2[i]\n  i += 1\n  if ((k1,k2) == (-1,-1)):\n   return (-1,-1)\n  c1,c2 = intersect((c1,c2),(k1,k2))\n  if ((c1,c2) == (-1,-1)):\n   return (c1,c2)\n return (c1,c2)\n \n \ntest = int(input())\nwhile (test != 0):\n test -= 1\n n = int(input())\n l = []\n i = 0\n while (i < n):\n  c1,c2 = list(map(int,input().split()))\n  l += [(c1,c2)]\n  i += 1\n if (n == 1):\n  print(1)\n  print(\"0 Inf\")\n else:\n  l1,l2 = (get(l,n))\n  k1,k2 = aa(l1,l2,n)\n  if ((k1,k2) == (-1,-1)):\n   k1,k2 = aa(l2,l1,n)\n   if ((k1,k2) == (-1,-1)):\n    print(0)\n   else:\n    print(1)\n    if (k2 == 10**20):\n     k2 = \"Inf\"\n    print(str(k1) + \" \" +str(k2))\n  else:\n   k3,k4 = aa(l2,l1,n)\n   if ((k3,k4) == (-1,-1)):\n    print(1)\n    if (k2 == 10**20):\n     k2 = \"Inf\"\n    print(str(k1) + \" \" +str(k2))\n   else:\n    p = union((k1,k2),(k3,k4))\n    if (len(p)==2):\n     c1,c2 = p\n     if (c2==10**20):\n      c2 = \"Inf\"\n     print(1)\n     print(str(c1) + \" \" +str(c2))\n    else:\n     c1,c2,c3,c4 = p\n     if (c4 == 10**20):\n      c4 = \"Inf\"\n     print(2)\n     print(str(c1) + \" \" +str(c2))\n     print(str(c3) + \" \" +str(c4))","mc_cc":6.8,"transformed_mc":["\nimport math\n\ndef calculate_interval(xh, m, even):\n    x = [x for x in xh]\n    y = [y for y in m]\n    up = []\n    lw = []\n    L = None\n    R = None\n    \n    for i in range(0, len(x) - 1):\n        if (i % 2 == even):\n            if ((y[i] - y[i + 1]) == 0):\n                if (x[i] < x[i + 1]):\n                    lw.append(0)\n                else:\n                    return False\n            else:\n                if (y[i] < y[i + 1]):\n                    l = (float)(x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                    l = int(math.floor(l)) + 1\n                    lw.append(max(0, l))\n                else:\n                    r = (float)(x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                    r = int(math.ceil(r)) - 1\n                    if (r < 0):\n                        return False\n                    up.append(r)\n        else:\n            if ((y[i] - y[i + 1]) == 0):\n                if (x[i] > x[i + 1]):\n                    lw.append(0)\n                else:\n                    return False\n            else:\n                if (y[i] > y[i + 1]):\n                    l = (float)(x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                    l = int(math.floor(l)) + 1\n                    lw.append(max(0, l))\n                else:\n                    r = (float)(x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                    r = int(math.ceil(r)) - 1\n                    if (r < 0):\n                        return False\n                    up.append(r)\n    \n    if len(lw) > 0:\n        L = max(lw)\n    else:\n        L = 0\n    \n    if len(up) > 0:\n        R = min(up)\n        if L > R:\n            return False\n    else:\n        R = \"Inf\"\n    \n    return L, R\n\ndef find_intervals(xh, m):\n    res = []\n    p = calculate_interval(xh, m, 0)\n    q = calculate_interval(xh, m, 1)\n    \n    if p is not False:\n        res.append(p)\n    if q is not False:\n        res.append(q)\n    \n    return res\n\ndef main():\n    T = int(input())\n    while T:\n        T = T - 1\n        N = int(input())\n        xh = []\n        m = []\n        \n        for i in range(N):\n            a, b = list(map(int, input().split()))\n            xh.append(a)\n            m.append(b)\n        \n        res = find_intervals(xh, m)\n        res.sort()\n        sz = len(res)\n        \n        if N == 1:\n            print(\"1\")\n            print(\"0 Inf\")\n        else:\n            if sz == 2 and (res[0][1] + 1 == res[1][0]):\n                print(\"1\")\n                print(res[0][0], res[1][1])\n            else:\n                print(sz)\n                for L, R in res:\n                    print(L, R)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["import math\n\nT = int(input())\nwhile T:\n    T -= 1\n    N = int(input())\n    xh = []\n    m = []\n    for _ in range(N):\n        a, b = map(int, input().split())\n        xh.append(a)\n        m.append(b)\n    \n    res = []\n    for even in [0, 1]:\n        x = [x for x in xh]\n        y = [y for y in m]\n        up = []\n        lw = []\n        L = None\n        R = None\n        valid = True\n        for i in range(0, len(x) - 1):\n            if (i % 2 == even):\n                if (y[i] - y[i + 1]) == 0:\n                    if x[i] < x[i + 1]:\n                        lw.append(0)\n                    else:\n                        valid = False\n                        break\n                else:\n                    if y[i] < y[i + 1]:\n                        l = (x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                        l = int(math.floor(l)) + 1\n                        lw.append(max(0, l))\n                    else:\n                        r = (x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                        r = int(math.ceil(r)) - 1\n                        if r < 0:\n                            valid = False\n                            break\n                        up.append(r)\n            else:\n                if (y[i] - y[i + 1]) == 0:\n                    if x[i] > x[i + 1]:\n                        lw.append(0)\n                    else:\n                        valid = False\n                        break\n                else:\n                    if y[i] > y[i + 1]:\n                        l = (x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                        l = int(math.floor(l)) + 1\n                        lw.append(max(0, l))\n                    else:\n                        r = (x[i + 1] - x[i]) \/ (y[i] - y[i + 1])\n                        r = int(math.ceil(r)) - 1\n                        if r < 0:\n                            valid = False\n                            break\n                        up.append(r)\n        if not valid:\n            continue\n        if len(lw) > 0:\n            L = max(lw)\n        else:\n            L = 0\n        if len(up) > 0:\n            R = min(up)\n            if L > R:\n                continue\n        else:\n            R = float('inf')\n        res.append((L, R))\n    \n    res.sort()\n    sz = len(res)\n    if N == 1:\n        print(\"1\")\n        print(\"0 Inf\")\n    else:\n        if sz == 2 and (res[0][1] + 1 == res[1][0]):\n            print(\"1\")\n            print(res[0][0], res[1][1])\n        else:\n            print(sz)\n            for interval in res:\n                L, R = interval\n                if R == float('inf'):\n                    print(L, \"Inf\")\n                else:\n                    print(L, R)"]}
{"problem_id":2348,"problem_description":"N hotels are located on a straight line. The coordinate of the i-th hotel (1 \\leq i \\leq N) is x_i.\nTak the traveler has the following two personal principles:\n - He never travels a distance of more than L in a single day.\n - He never sleeps in the open. That is, he must stay at a hotel at the end of a day.\nYou are given Q queries. The j-th (1 \\leq j \\leq Q) query is described by two distinct integers a_j and b_j.\nFor each query, find the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel following his principles.\nIt is guaranteed that he can always travel from the a_j-th hotel to the b_j-th hotel, in any given input.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq L \\leq 10^9\n - 1 \\leq Q \\leq 10^5\n - 1 \\leq x_i < x_2 < ... < x_N \\leq 10^9\n - x_{i+1} - x_i \\leq L\n - 1 \\leq a_j,b_j \\leq N\n - a_j \\neq b_j\n - N,\\,L,\\,Q,\\,x_i,\\,a_j,\\,b_j are integers.\n\n-----Partial Score-----\n - 200 points will be awarded for passing the test set satisfying N \\leq 10^3 and Q \\leq 10^3.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nx_1 x_2 ... x_N\nL\nQ\na_1 b_1\na_2 b_2\n:\na_Q b_Q\n\n-----Output-----\nPrint Q lines.\nThe j-th line (1 \\leq j \\leq Q) should contain the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel.\n\n-----Sample Input-----\n9\n1 3 6 13 15 18 19 29 31\n10\n4\n1 8\n7 3\n6 7\n8 5\n\n-----Sample Output-----\n4\n2\n1\n2\n\nFor the 1-st query, he can travel from the 1-st hotel to the 8-th hotel in 4 days, as follows:\n - Day 1: Travel from the 1-st hotel to the 2-nd hotel. The distance traveled is 2.\n - Day 2: Travel from the 2-nd hotel to the 4-th hotel. The distance traveled is 10.\n - Day 3: Travel from the 4-th hotel to the 7-th hotel. The distance traveled is 6.\n - Day 4: Travel from the 7-th hotel to the 8-th hotel. The distance traveled is 10.","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"import bisect\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int,input().split()))\nd = int(input())\ngraph = [[0 for i in range(n+1)] for j in range(18)]\nfor i in range(n):\n  x = bisect.bisect_right(a,a[i]+d)\n  graph[0][i+1] = x\nfor j in range(1,18):\n  for i in range(n):\n    t = graph[j-1][i+1]\n    graph[j][i+1] = graph[j-1][t]\nq = int(input())\nfor _ in range(q):\n  x,y = map(int,input().split())\n  x,y = min(x,y),max(x,y)\n  ans = 0\n  for j in range(18)[::-1]:\n    if graph[j][x] < y:\n      ans += 2**j\n      x = graph[j][x]\n    if j == 0 and x < y:\n      ans += 1\n  print(ans)","sc_cc":11.0,"mc":"def reachN(i0, n):\n    if n == 0:\n        return i0\n    maxbit = ceil(log2(n))\n    kL = []\n    for i in range(maxbit+1):\n        if n>>i & 1:\n            kL.append(i)\n    \n    i = i0\n    for k in kL[::-1]:\n        i = dp[k][i]      \n    return i   \n\ndef fun(n):\n    return reachN(start, n) >= goal\n    \ndef binMin(l, r):\n    if r-l == 1:\n        return r\n    m = (l+r) \/\/ 2\n    if fun(m):\n        r = m\n    else:\n        l = m\n    return binMin(l, r)\n\nimport bisect\nfrom math import log2, ceil\n\nN = int(input())\nxL = [-float('inf')] + [int(i) for i in input().split()]   \nLmax = int(input())\n\nkmax = ceil(log2(len(xL)-2))                               \ndp = [[len(xL)-1]*(N+1) for _ in range(kmax+1)]\nfor i in range(1, N+1):\n    dp[0][i] = bisect.bisect_right(xL, xL[i]+Lmax) - 1\n\nfor k in range(1, kmax+1):\n    for i in range(1, N):\n        dp[k][i] = dp[k-1][dp[k-1][i]]\n\n\nQ = int(input())\nfor _ in range(Q):\n    start, goal = list(map(int, input().split()))\n    if start > goal:\n        start, goal = goal, start\n    ans = binMin(0, goal-start)\n    print(ans)","mc_cc":4.25,"transformed_mc":["\nimport bisect\nimport sys\n\ndef build_graph(n, a, d):\n    graph = [[0 for _ in range(n + 1)] for _ in range(18)]\n    for i in range(n):\n        x = bisect.bisect_right(a, a[i] + d)\n        graph[0][i + 1] = x\n    for j in range(1, 18):\n        for i in range(n):\n            t = graph[j - 1][i + 1]\n            graph[j][i + 1] = graph[j - 1][t]\n    return graph\n\ndef calculate_days(graph, x, y):\n    x, y = min(x, y), max(x, y)\n    ans = 0\n    for j in range(18)[::-1]:\n        if graph[j][x] < y:\n            ans += 2 ** j\n            x = graph[j][x]\n        if j == 0 and x < y:\n            ans += 1\n    return ans\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = int(input())\n    graph = build_graph(n, a, d)\n    \n    q = int(input())\n    for _ in range(q):\n        x, y = map(int, input().split())\n        ans = calculate_days(graph, x, y)\n        print(ans)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["import bisect\nimport sys\n\nn = int(input())\na = list(map(int, input().split()))\nd = int(input())\n\ngraph = [[0 for _ in range(n + 1)] for _ in range(18)]\nfor i in range(n):\n    x = bisect.bisect_right(a, a[i] + d)\n    graph[0][i + 1] = x\nfor j in range(1, 18):\n    for i in range(n):\n        t = graph[j - 1][i + 1]\n        graph[j][i + 1] = graph[j - 1][t]\n\nq = int(input())\nfor _ in range(q):\n    x, y = map(int, input().split())\n    x, y = min(x, y), max(x, y)\n    ans = 0\n    \n    for j in range(18)[::-1]:\n        if graph[j][x] < y:\n            ans += 2 ** j\n            x = graph[j][x]\n        if j == 0 and x < y:\n            ans += 1\n    print(ans)"]}
