{"problem_id":1596,"problem_description":"During quarantine chef\u2019s friend invented a game. In this game there are two players, player 1 and Player 2. In center of garden there is one finish circle and both players are at different distances respectively $X$ and $Y$ from finish circle.\nBetween finish circle and Player 1 there are $X$ number of circles and between finish circle and Player 2 there are $Y$ number of circles. Both player wants to reach finish circle with minimum number of jumps. Player can jump one circle to another circle.\nBoth players can skip $2^0-1$ or $2^1- 1$ or \u2026. or $2^N-1$ circles per jump. A player cannot skip same number of circles in a match more than once. If both players uses optimal way to reach finish circle what will be the difference of minimum jumps needed to reach finish circle by both players. \nIf both players reach finish circle with same number of jumps answer will be $0$ $0$.\n\n-----Input:-----\n- The first line of the input contains a single integer $T$ denoting the number of test cases. The \ndescription of $T$ test cases follows.\n- The first line of each test case contains 2 space separated integers $X$ and $Y$.\n\n-----Output:-----\nFor each test case, print a single line containing 2 space-separated integers which player win and what is the difference between number of minimum jump required by both players to reach finish circle.\n\n-----Constraints-----\n- $1 \\leq T \\leq 10^5$\n- $1 \\leq X,Y \\leq 2*10^7$\n\n-----Sample Input:-----\n2\n4 5\n3 5\n\n-----Sample Output:-----\n0 0\n1 1\n\n-----Explanation:-----\nTest Case 1:\n\nTest Case 2:","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"import math\n\nfor i in range(int(input())):\n p,q=list(map(int,input().split()))\n c=0\n h=0\n \n while(q>=0):\n  if(q==0):\n   h+=1\n   break\n  \n  d=int(math.log2(q+1))\n  if(d==0):\n   h+=1\n   break\n  y=(2**d)-1\n  q-=y+1\n  if(q==-1):\n   h+=1\n   break\n  h+=1\n  \n while(p>=0):\n  if(p==0):\n   c+=1\n   break\n  else:\n   rem=int(math.log2(p+1))\n  \n   if(rem==0):\n    c+=1\n    break\n   \n   y=(2**rem)-1\n   p-=y+1\n   if(p==-1):\n    c+=1\n    break\n   c+=1\n\n if(c==h):\n  print(0,0)\n if(c<h):\n  print(1,h-c)\n if(c>h):\n  print(2,c-h)","sc_cc":13.0,"mc":"takeArr = lambda: list(map(int,input().split()))\ntakeList = lambda: list(map(int,input().split()))\nimport sys\nsys.setrecursionlimit(10**6)\n\n\n\nfrom math import floor,ceil,log2 \ndef powOfPositive(n) :  \n pos = floor(log2(n));  \n return 2**pos;  \ndef powOfNegative(n) : \n pos = ceil(log2(n));  \n return (-1 * pow(2, pos));   \ndef highestPowerOf2(n) :  \n if (n > 0) : \n  return powOfPositive(n);  \n else :   \n  n = -n;  \n  return powOfNegative(n);  \ndef main(t):\n x,y = takeArr()\n a,b = x+1,y+1\n sa = sb = 0\n while a:\n  a -= highestPowerOf2(a)\n  sa += 1\n while b:\n  b -= highestPowerOf2(b)\n  sb += 1\n \n winner = 2 if sa>sb else 1 if sb>sa else 0\n score = abs(sa-sb) if winner else 0\n print(winner,score)\n if t>1:\n  main(t-1)\nmain(int(input()))","mc_cc":2.4,"transformed_mc":["\nimport math\n\ndef calculate_jumps(distance):\n    jumps = 0\n    while distance >= 0:\n        if distance == 0:\n            jumps += 1\n            break\n\n        power = int(math.log2(distance + 1))\n        if power == 0:\n            jumps += 1\n            break\n        step = (2 ** power) - 1\n        distance -= step + 1\n        if distance == -1:\n            jumps += 1\n            break\n        jumps += 1\n\n    return jumps\n\ndef determine_winner_and_difference(player1_distance, player2_distance):\n    player1_jumps = calculate_jumps(player1_distance)\n    player2_jumps = calculate_jumps(player2_distance)\n\n    if player1_jumps == player2_jumps:\n        return 0, 0\n    elif player1_jumps < player2_jumps:\n        return 1, player2_jumps - player1_jumps\n    else:\n        return 2, player1_jumps - player2_jumps\n\ndef main():\n    for _ in range(int(input())):\n        player1_distance, player2_distance = map(int, input().split())\n        winner, difference = determine_winner_and_difference(player1_distance, player2_distance)\n        print(winner, difference)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["import math\n\nfor _ in range(int(input())):\n    player1_distance, player2_distance = map(int, input().split())\n    \n    jumps = 0\n    distance = player1_distance\n    while distance >= 0:\n        if distance == 0:\n            jumps += 1\n            break\n        power = int(math.log2(distance + 1))\n        if power == 0:\n            jumps += 1\n            break\n        step = (2 ** power) - 1\n        distance -= step + 1\n        if distance == -1:\n            jumps += 1\n            break\n        jumps += 1\n    player1_jumps = jumps\n    \n    jumps = 0\n    distance = player2_distance\n    while distance >= 0:\n        if distance == 0:\n            jumps += 1\n            break\n        power = int(math.log2(distance + 1))\n        if power == 0:\n            jumps += 1\n            break\n        step = (2 ** power) - 1\n        distance -= step + 1\n        if distance == -1:\n            jumps += 1\n            break\n        jumps += 1\n    player2_jumps = jumps\n    \n    if player1_jumps == player2_jumps:\n        winner = 0\n        difference = 0\n    elif player1_jumps < player2_jumps:\n        winner = 1\n        difference = player2_jumps - player1_jumps\n    else:\n        winner = 2\n        difference = player1_jumps - player2_jumps\n    \n    print(winner, difference)"]}
{"problem_id":2348,"problem_description":"N hotels are located on a straight line. The coordinate of the i-th hotel (1 \\leq i \\leq N) is x_i.\nTak the traveler has the following two personal principles:\n - He never travels a distance of more than L in a single day.\n - He never sleeps in the open. That is, he must stay at a hotel at the end of a day.\nYou are given Q queries. The j-th (1 \\leq j \\leq Q) query is described by two distinct integers a_j and b_j.\nFor each query, find the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel following his principles.\nIt is guaranteed that he can always travel from the a_j-th hotel to the b_j-th hotel, in any given input.\n\n-----Constraints-----\n - 2 \\leq N \\leq 10^5\n - 1 \\leq L \\leq 10^9\n - 1 \\leq Q \\leq 10^5\n - 1 \\leq x_i < x_2 < ... < x_N \\leq 10^9\n - x_{i+1} - x_i \\leq L\n - 1 \\leq a_j,b_j \\leq N\n - a_j \\neq b_j\n - N,\\,L,\\,Q,\\,x_i,\\,a_j,\\,b_j are integers.\n\n-----Partial Score-----\n - 200 points will be awarded for passing the test set satisfying N \\leq 10^3 and Q \\leq 10^3.\n\n-----Input-----\nThe input is given from Standard Input in the following format:\nN\nx_1 x_2 ... x_N\nL\nQ\na_1 b_1\na_2 b_2\n:\na_Q b_Q\n\n-----Output-----\nPrint Q lines.\nThe j-th line (1 \\leq j \\leq Q) should contain the minimum number of days that Tak needs to travel from the a_j-th hotel to the b_j-th hotel.\n\n-----Sample Input-----\n9\n1 3 6 13 15 18 19 29 31\n10\n4\n1 8\n7 3\n6 7\n8 5\n\n-----Sample Output-----\n4\n2\n1\n2\n\nFor the 1-st query, he can travel from the 1-st hotel to the 8-th hotel in 4 days, as follows:\n - Day 1: Travel from the 1-st hotel to the 2-nd hotel. The distance traveled is 2.\n - Day 2: Travel from the 2-nd hotel to the 4-th hotel. The distance traveled is 10.\n - Day 3: Travel from the 4-th hotel to the 7-th hotel. The distance traveled is 6.\n - Day 4: Travel from the 7-th hotel to the 8-th hotel. The distance traveled is 10.","starter_code":"","sc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Please wrap your code answer using ```:","mc_instruction":"Write a python code to solve the following coding problem that obeys the constraints and passes the example test cases. The output code needs to read from and write to standard IO. Ensure modularity of the python code by dividing the code into smaller, useful functions to solve the given problem. Please wrap your code answer using ```:","sc":"import bisect\nimport sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int,input().split()))\nd = int(input())\ngraph = [[0 for i in range(n+1)] for j in range(18)]\nfor i in range(n):\n  x = bisect.bisect_right(a,a[i]+d)\n  graph[0][i+1] = x\nfor j in range(1,18):\n  for i in range(n):\n    t = graph[j-1][i+1]\n    graph[j][i+1] = graph[j-1][t]\nq = int(input())\nfor _ in range(q):\n  x,y = map(int,input().split())\n  x,y = min(x,y),max(x,y)\n  ans = 0\n  for j in range(18)[::-1]:\n    if graph[j][x] < y:\n      ans += 2**j\n      x = graph[j][x]\n    if j == 0 and x < y:\n      ans += 1\n  print(ans)","sc_cc":11.0,"mc":"def reachN(i0, n):\n    if n == 0:\n        return i0\n    maxbit = ceil(log2(n))\n    kL = []\n    for i in range(maxbit+1):\n        if n>>i & 1:\n            kL.append(i)\n    \n    i = i0\n    for k in kL[::-1]:\n        i = dp[k][i]      \n    return i   \n\ndef fun(n):\n    return reachN(start, n) >= goal\n    \ndef binMin(l, r):\n    if r-l == 1:\n        return r\n    m = (l+r) \/\/ 2\n    if fun(m):\n        r = m\n    else:\n        l = m\n    return binMin(l, r)\n\nimport bisect\nfrom math import log2, ceil\n\nN = int(input())\nxL = [-float('inf')] + [int(i) for i in input().split()]   \nLmax = int(input())\n\nkmax = ceil(log2(len(xL)-2))                               \ndp = [[len(xL)-1]*(N+1) for _ in range(kmax+1)]\nfor i in range(1, N+1):\n    dp[0][i] = bisect.bisect_right(xL, xL[i]+Lmax) - 1\n\nfor k in range(1, kmax+1):\n    for i in range(1, N):\n        dp[k][i] = dp[k-1][dp[k-1][i]]\n\n\nQ = int(input())\nfor _ in range(Q):\n    start, goal = list(map(int, input().split()))\n    if start > goal:\n        start, goal = goal, start\n    ans = binMin(0, goal-start)\n    print(ans)","mc_cc":4.25,"transformed_mc":["\nimport bisect\nimport sys\n\ndef hotel_distances(n, a, d):\n    graph = [[0 for i in range(n+1)] for j in range(18)]\n    for i in range(n):\n        x = bisect.bisect_right(a, a[i] + d)\n        graph[0][i+1] = x\n    for j in range(1, 18):\n        for i in range(n):\n            t = graph[j-1][i+1]\n            graph[j][i+1] = graph[j-1][t]\n    return graph\n\ndef calculate_days_to_travel(graph, x, y):\n    x, y = min(x, y), max(x, y)\n    days = 0\n    for j in range(18)[::-1]:\n        if graph[j][x] < y:\n            days += 2**j\n            x = graph[j][x]\n        if j == 0 and x < y:\n            days += 1\n    return days\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    d = int(input())\n    graph = hotel_distances(n, a, d)\n    q = int(input())\n    for _ in range(q):\n        x, y = map(int, input().split())\n        days = calculate_days_to_travel(graph, x, y)\n        print(days)\n\nif __name__ == '__main__':\n    main()\n"],"transformed_sc":["import bisect\nimport sys\n\ndef hotel_distances(n, a, d):\n    graph = [[0 for i in range(n+1)] for j in range(18)]\n    for i in range(n):\n        x = bisect.bisect_right(a, a[i] + d)\n        graph[0][i+1] = x\n    for j in range(1, 18):\n        for i in range(n):\n            t = graph[j-1][i+1]\n            graph[j][i+1] = graph[j-1][t]\n    return graph\n\ndef calculate_days_to_travel(graph, x, y):\n    x, y = min(x, y), max(x, y)\n    days = 0\n    for j in range(18)[::-1]:\n        if graph[j][x] < y:\n            days += 2**j\n            x = graph[j][x]\n        if j == 0 and x < y:\n            days += 1\n    return days\n\nn = int(input())\na = list(map(int, input().split()))\nd = int(input())\ngraph = [[0 for i in range(n+1)] for j in range(18)]\nfor i in range(n):\n    x = bisect.bisect_right(a, a[i] + d)\n    graph[0][i+1] = x\nfor j in range(1, 18):\n    for i in range(n):\n        t = graph[j-1][i+1]\n        graph[j][i+1] = graph[j-1][t]\n\nq = int(input())\nfor _ in range(q):\n    x, y = map(int, input().split())\n    x, y = min(x, y), max(x, y)\n    days = 0\n    for j in range(18)[::-1]:\n        if graph[j][x] < y:\n            days += 2**j\n            x = graph[j][x]\n        if j == 0 and x < y:\n            days += 1\n    print(days)"]}
